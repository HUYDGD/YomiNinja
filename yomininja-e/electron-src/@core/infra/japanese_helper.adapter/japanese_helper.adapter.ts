import { AutoGeneratedFurigana, GenerateFurigana_Input, GenerateFurigana_Output, JapaneseHelperAdapter } from "../../application/adapters/japanese_helper.adapter";


export class JapaneseHelper implements JapaneseHelperAdapter {


    isKanji( character: string ) {
        // Define a regular expression pattern to match kanji characters
        const kanjiPattern = /[\u4e00-\u9faf\u3400-\u4dbf]/;
        return kanjiPattern.test(character);
    }
    
    generateFurigana( input: GenerateFurigana_Input ): GenerateFurigana_Output {

        const { term, reading } = input;

        let furiganaArray = [];
        let furiganaRangesArray: string[] = [];
      
        let readingIndex = 0;
        let currentFurigana = '';
      
      
        for ( let termIndex = 0; termIndex < term.length; termIndex++ ) {
      
            const getCurrentChar = () => term[termIndex];
            const getNextChar = () => term[termIndex+1];
            const isCurrentCharKanji = () => this.isKanji( getCurrentChar() );
        
            const currentCharMatchesCurrentReading = () => getCurrentChar() === reading[readingIndex];
            const nextCharMatchesCurrentReading = () => getNextChar() === reading[readingIndex];
            const isNextCharKanji = () => this.isKanji( getNextChar() );
        
            let furiganaRange;
        
            if ( isCurrentCharKanji() )
                furiganaRange = termIndex.toString();
            
            if ( currentCharMatchesCurrentReading() ) {
                readingIndex++;
                continue;
            }
            else if ( !furiganaRange ) {            
                furiganaArray = [ reading ];
                furiganaRangesArray = ['0-'+(term.length-1)];
                // console.log({ termIndex, furiganaRange, currentFurigana })
                break;
            }
        
            // Moving to the last kanji of current kanji word
            while( isNextCharKanji() && termIndex < term.length ) {
        
                if ( !furiganaRange && isCurrentCharKanji() )
                    furiganaRange = termIndex.toString();
        
                termIndex++;
            }
        
            if ( !furiganaRange && isCurrentCharKanji() )
                furiganaRange = termIndex.toString();
            
        
            while ( 
                !nextCharMatchesCurrentReading() &&
                readingIndex < reading.length
                // isCurrentCharKanji()
            ) {
        
                currentFurigana += reading[readingIndex];
                
                readingIndex++;
            }
        
            if ( currentFurigana ) {
                furiganaArray.push( currentFurigana );
                furiganaRange += '-' + termIndex.toString();
        
                furiganaRangesArray.push(furiganaRange);
                currentFurigana = "";            
            }
        }
    
        const furigana: AutoGeneratedFurigana[] = [];
    
        const formatedFurigana: string = furiganaArray.map( ( furiganaItem, idx ) => {
    
                const range = furiganaRangesArray[ idx ];
    
                const [ startIdx, endIdx ] = range.split('-')
                    .map( value => Number(value) );
    
                furigana.push({
                    text: furiganaItem,
                    startIdx,
                    endIdx,
                })
    
                return `${range}:${furiganaItem}`;
            })
            .join(';');        
      
        return {
            formatedFurigana,
            furigana
        }
    }
}